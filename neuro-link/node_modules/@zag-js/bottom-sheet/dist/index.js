'use strict';

var anatomy$1 = require('@zag-js/anatomy');
var domQuery = require('@zag-js/dom-query');
var core = require('@zag-js/core');
var dismissable = require('@zag-js/dismissable');
var focusTrap = require('@zag-js/focus-trap');
var removeScroll = require('@zag-js/remove-scroll');
var ariaHidden = require('@zag-js/aria-hidden');
var types = require('@zag-js/types');
var utils = require('@zag-js/utils');

// src/bottom-sheet.anatomy.ts
var anatomy = anatomy$1.createAnatomy("bottom-sheet").parts(
  "content",
  "title",
  "trigger",
  "backdrop",
  "grabber",
  "grabberIndicator",
  "closeTrigger"
);
var parts = anatomy.build();
var getContentId = (ctx) => ctx.ids?.content ?? `bottom-sheet:${ctx.id}:content`;
var getTitleId = (ctx) => ctx.ids?.title ?? `bottom-sheet:${ctx.id}:title`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `bottom-sheet:${ctx.id}:trigger`;
var getBackdropId = (ctx) => ctx.ids?.backdrop ?? `bottom-sheet:${ctx.id}:backdrop`;
var getGrabberId = (ctx) => ctx.ids?.grabber ?? `bottom-sheet:${ctx.id}:grabber`;
var getGrabberIndicatorId = (ctx) => ctx.ids?.grabberIndicator ?? `bottom-sheet:${ctx.id}:grabber-indicator`;
var getCloseTriggerId = (ctx) => ctx.ids?.closeTrigger ?? `bottom-sheet:${ctx.id}:close-trigger`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId(ctx));
var tap = (v, fn) => v != null ? fn(v) : void 0;
function connect(service, normalize) {
  const { state, send, context, scope, prop } = service;
  function onPointerDown(event) {
    if (!domQuery.isLeftClick(event)) return;
    const target = domQuery.getEventTarget(event);
    if (target?.hasAttribute("data-no-drag") || target?.closest("[data-no-drag]")) return;
    if (state.matches("closing")) return;
    const point = domQuery.getEventPoint(event);
    send({ type: "POINTER_DOWN", point });
  }
  const open = state.hasTag("open");
  const dragging = state.hasTag("dragging");
  const translate = context.get("dragOffset") ?? context.get("resolvedActiveSnapPoint")?.offset;
  return {
    open,
    activeSnapPoint: context.get("activeSnapPoint"),
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setActiveSnapPoint(snapPoint) {
      const activeSnapPoint = context.get("activeSnapPoint");
      if (activeSnapPoint === snapPoint) return;
      send({ type: "SET_ACTIVE_SNAP_POINT", snapPoint });
    },
    getContentProps(props2 = { draggable: true }) {
      return normalize.element({
        ...parts.content.attrs,
        dir: prop("dir"),
        id: getContentId(scope),
        tabIndex: -1,
        role: "dialog",
        "aria-modal": "true",
        "aria-labelledby": getTitleId(scope),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        style: {
          transform: "translate3d(0, var(--bottom-sheet-translate, 0), 0)",
          transitionDuration: dragging ? "0s" : void 0,
          "--bottom-sheet-translate": tap(translate, (v) => `${v}px`),
          willChange: "transform"
        },
        onPointerDown(event) {
          if (!props2.draggable) return;
          onPointerDown(event);
        }
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts.title.attrs,
        id: getTitleId(scope),
        dir: prop("dir")
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        id: getTriggerId(scope),
        type: "button",
        onClick() {
          send({ type: open ? "CLOSE" : "OPEN" });
        }
      });
    },
    getBackdropProps() {
      return normalize.element({
        ...parts.backdrop.attrs,
        id: getBackdropId(scope),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        style: {
          willChange: "opacity"
        }
      });
    },
    getGrabberProps() {
      return normalize.element({
        ...parts.grabber.attrs,
        id: getGrabberId(scope),
        onPointerDown(event) {
          onPointerDown(event);
        },
        style: {
          touchAction: "none"
        }
      });
    },
    getGrabberIndicatorProps() {
      return normalize.element({
        ...parts.grabberIndicator.attrs,
        id: getGrabberIndicatorId(scope)
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        ...parts.closeTrigger.attrs,
        id: getCloseTriggerId(scope),
        onClick() {
          send({ type: "CLOSE" });
        }
      });
    }
  };
}

// src/utils/resolve-snap-point.ts
function resolveSnapPoint(snapPoint, containerHeight) {
  if (typeof snapPoint === "number") {
    return {
      value: snapPoint,
      offset: containerHeight - snapPoint * containerHeight
    };
  }
  if (typeof snapPoint === "string") {
    return {
      value: snapPoint,
      offset: containerHeight - parseFloat(snapPoint)
    };
  }
  throw new Error(`Invalid snap point: ${snapPoint}`);
}

// src/utils/find-closest-snap-point.ts
function findClosestSnapPoint(offset, snapPoints) {
  return snapPoints.reduce((acc, curr) => {
    const closestDiff = Math.abs(offset - acc.offset);
    const currentDiff = Math.abs(offset - curr.offset);
    return currentDiff < closestDiff ? curr : acc;
  });
}

// src/utils/get-scroll-info.ts
function isScrollContainer(element) {
  const styles = getComputedStyle(element);
  const overflow = styles.overflowY;
  return overflow === "auto" || overflow === "scroll";
}
function getScrollInfo(target, container) {
  let element = target;
  let availableScroll = 0;
  let availableScrollTop = 0;
  while (element) {
    const { clientHeight, scrollTop, scrollHeight } = element;
    const scrolled = scrollHeight - scrollTop - clientHeight;
    if ((scrollTop !== 0 || scrolled !== 0) && isScrollContainer(element)) {
      availableScroll += scrolled;
      availableScrollTop += scrollTop;
    }
    if (element === container || element === document.documentElement) break;
    element = element.parentNode;
  }
  return {
    availableScroll,
    availableScrollTop
  };
}

// src/bottom-sheet.machine.ts
var machine = core.createMachine({
  props({ props: props2, scope }) {
    const alertDialog = props2.role === "alertdialog";
    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;
    const modal = typeof props2.modal === "boolean" ? props2.modal : true;
    return {
      modal,
      trapFocus: modal,
      preventScroll: modal,
      closeOnInteractOutside: true,
      closeOnEscape: true,
      restoreFocus: true,
      initialFocusEl,
      snapPoints: [1],
      defaultActiveSnapPoint: 1,
      swipeVelocityThreshold: 500,
      closeThreshold: 0.25,
      preventDragOnScroll: true,
      ...props2
    };
  },
  context({ bindable, prop }) {
    return {
      pointerStart: bindable(() => ({
        defaultValue: null
      })),
      dragOffset: bindable(() => ({
        defaultValue: null
      })),
      activeSnapPoint: bindable(() => ({
        defaultValue: prop("defaultActiveSnapPoint"),
        value: prop("activeSnapPoint"),
        onChange(value) {
          return prop("onActiveSnapPointChange")?.({ snapPoint: value });
        }
      })),
      resolvedActiveSnapPoint: bindable(() => ({
        defaultValue: null
      })),
      contentHeight: bindable(() => ({
        defaultValue: null
      })),
      lastPoint: bindable(() => ({
        defaultValue: null
      })),
      lastTimestamp: bindable(() => ({
        defaultValue: null
      })),
      velocity: bindable(() => ({
        defaultValue: null
      }))
    };
  },
  computed: {
    resolvedSnapPoints({ context, prop }) {
      const contentHeight = context.get("contentHeight");
      if (contentHeight === null) return [];
      return prop("snapPoints").map((snapPoint) => resolveSnapPoint(snapPoint, contentHeight));
    }
  },
  watch({ track, context, prop, action }) {
    track([() => context.get("activeSnapPoint"), () => context.get("contentHeight")], () => {
      const activeSnapPoint = context.get("activeSnapPoint");
      const contentHeight = context.get("contentHeight");
      if (contentHeight === null) return;
      const resolvedActiveSnapPoint = resolveSnapPoint(activeSnapPoint, contentHeight);
      context.set("resolvedActiveSnapPoint", resolvedActiveSnapPoint);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  on: {
    SET_ACTIVE_SNAP_POINT: {
      actions: ["setActiveSnapPoint"]
    }
  },
  states: {
    open: {
      tags: ["open"],
      effects: [
        "trackDismissableElement",
        "preventScroll",
        "trapFocus",
        "hideContentBelow",
        "trackPointerMove",
        "trackContentHeight"
      ],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        POINTER_DOWN: [
          {
            actions: ["setPointerStart"]
          }
        ],
        POINTER_MOVE: [
          {
            guard: "shouldStartDragging",
            target: "open:dragging"
          }
        ],
        POINTER_UP: [
          {
            actions: ["clearPointerStart", "clearDragOffset"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closing",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    "open:dragging": {
      effects: ["trackDismissableElement", "preventScroll", "trapFocus", "hideContentBelow", "trackPointerMove"],
      tags: ["open", "dragging"],
      on: {
        POINTER_MOVE: [
          {
            actions: ["setDragOffset"]
          }
        ],
        POINTER_UP: [
          {
            guard: "shouldCloseOnSwipe",
            target: "closing"
          },
          {
            actions: ["setClosestSnapPoint", "clearPointerStart", "clearDragOffset"],
            target: "open"
          }
        ]
      }
    },
    closing: {
      effects: ["trackExitAnimation"],
      on: {
        ANIMATION_END: {
          target: "closed",
          actions: [
            "invokeOnClose",
            "clearPointerStart",
            "clearDragOffset",
            "clearActiveSnapPoint",
            "clearResolvedActiveSnapPoint",
            "clearContentHeight",
            "clearVelocityTracking"
          ]
        }
      }
    },
    closed: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      shouldStartDragging({ prop, context, event, scope, send }) {
        const pointerStart = context.get("pointerStart");
        const container = getContentEl(scope);
        if (!pointerStart || !container) return false;
        const { point, target } = event;
        if (prop("preventDragOnScroll")) {
          const delta = pointerStart.y - point.y;
          if (Math.abs(delta) < 0.3) return false;
          const { availableScroll, availableScrollTop } = getScrollInfo(target, container);
          if (delta > 0 && Math.abs(availableScroll) > 1 || delta < 0 && Math.abs(availableScrollTop) > 0) {
            send({ type: "POINTER_UP", point });
            return false;
          }
        }
        return true;
      },
      shouldCloseOnSwipe({ prop, context, computed }) {
        const velocity = context.get("velocity");
        const dragOffset = context.get("dragOffset");
        const contentHeight = context.get("contentHeight");
        const swipeVelocityThreshold = prop("swipeVelocityThreshold");
        const closeThreshold = prop("closeThreshold");
        const snapPoints = computed("resolvedSnapPoints");
        if (dragOffset === null || contentHeight === null || velocity === null) return false;
        const visibleHeight = contentHeight - dragOffset;
        const smallestSnapPoint = snapPoints.reduce((acc, curr) => curr.offset > acc.offset ? curr : acc);
        const isFastSwipe = velocity > 0 && velocity >= swipeVelocityThreshold;
        const closeThresholdInPixels = contentHeight * (1 - closeThreshold);
        const isBelowSmallestSnapPoint = visibleHeight < contentHeight - smallestSnapPoint.offset;
        const isBelowCloseThreshold = visibleHeight < closeThresholdInPixels;
        const hasEnoughDragToDismiss = isBelowCloseThreshold && isBelowSmallestSnapPoint || visibleHeight === 0;
        return isFastSwipe || hasEnoughDragToDismiss;
      }
    },
    actions: {
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      setActiveSnapPoint({ context, event }) {
        context.set("activeSnapPoint", event.snapPoint);
      },
      setPointerStart({ event, context }) {
        context.set("pointerStart", event.point);
      },
      setDragOffset({ context, event }) {
        const pointerStart = context.get("pointerStart");
        if (!pointerStart) return;
        const { point } = event;
        const currentTimestamp = (/* @__PURE__ */ new Date()).getTime();
        const lastPoint = context.get("lastPoint");
        if (lastPoint) {
          const dy = point.y - lastPoint.y;
          const lastTimestamp = context.get("lastTimestamp");
          if (lastTimestamp) {
            const dt = currentTimestamp - lastTimestamp;
            if (dt > 0) {
              context.set("velocity", dy / dt * 1e3);
            }
          }
        }
        context.set("lastPoint", point);
        context.set("lastTimestamp", currentTimestamp);
        let delta = pointerStart.y - point.y - (context.get("resolvedActiveSnapPoint")?.offset || 0);
        if (delta > 0) delta = 0;
        context.set("dragOffset", -delta);
      },
      setClosestSnapPoint({ computed, context }) {
        const snapPoints = computed("resolvedSnapPoints");
        const contentHeight = context.get("contentHeight");
        const dragOffset = context.get("dragOffset");
        if (!snapPoints || contentHeight === null || dragOffset === null) return;
        const closestSnapPoint = findClosestSnapPoint(dragOffset, snapPoints);
        context.set("activeSnapPoint", closestSnapPoint.value);
      },
      clearDragOffset({ context }) {
        context.set("dragOffset", null);
      },
      clearActiveSnapPoint({ context, prop }) {
        context.set("activeSnapPoint", prop("defaultActiveSnapPoint"));
      },
      clearResolvedActiveSnapPoint({ context }) {
        context.set("resolvedActiveSnapPoint", null);
      },
      clearPointerStart({ context }) {
        context.set("pointerStart", null);
      },
      clearContentHeight({ context }) {
        context.set("contentHeight", null);
      },
      clearVelocityTracking({ context }) {
        context.set("lastPoint", null);
        context.set("lastTimestamp", null);
        context.set("velocity", null);
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    },
    effects: {
      trackDismissableElement({ scope, prop, send }) {
        const getContentEl2 = () => getContentEl(scope);
        return dismissable.trackDismissableElement(getContentEl2, {
          defer: true,
          exclude: [getTriggerEl(scope)],
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          onFocusOutside: prop("onFocusOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (!prop("closeOnEscape")) {
              event.preventDefault();
            }
          },
          onPointerDownOutside: prop("onPointerDownOutside"),
          onRequestDismiss: prop("onRequestDismiss"),
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          }
        });
      },
      preventScroll({ scope, prop }) {
        if (!prop("preventScroll")) return;
        return removeScroll.preventBodyScroll(scope.getDoc());
      },
      trapFocus({ scope, prop }) {
        if (!prop("trapFocus")) return;
        const contentEl = () => getContentEl(scope);
        return focusTrap.trapFocus(contentEl, {
          preventScroll: true,
          returnFocusOnDeactivate: !!prop("restoreFocus"),
          initialFocus: prop("initialFocusEl"),
          setReturnFocus: (el) => prop("finalFocusEl")?.() || el
        });
      },
      hideContentBelow({ scope, prop }) {
        if (!prop("modal")) return;
        const getElements = () => [getContentEl(scope)];
        return ariaHidden.ariaHidden(getElements, { defer: true });
      },
      trackPointerMove({ scope, send, prop }) {
        let lastY = 0;
        function onPointerMove(event) {
          const point = domQuery.getEventPoint(event);
          const target = domQuery.getEventTarget(event);
          send({ type: "POINTER_MOVE", point, target });
        }
        function onPointerUp(event) {
          if (event.pointerType !== "touch") {
            const point = domQuery.getEventPoint(event);
            send({ type: "POINTER_UP", point });
          }
        }
        function onTouchStart(event) {
          if (!event.touches[0]) return;
          lastY = event.touches[0].clientY;
        }
        function onTouchMove(event) {
          if (!event.touches[0]) return;
          const point = domQuery.getEventPoint(event);
          const target = event.target;
          if (!prop("preventDragOnScroll")) {
            send({ type: "POINTER_MOVE", point, target });
            return;
          }
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          let el = target;
          while (el && el !== contentEl && el.scrollHeight <= el.clientHeight) {
            el = el.parentElement;
          }
          if (el && el !== contentEl) {
            const scrollTop = el.scrollTop;
            const y = event.touches[0].clientY;
            const atTop = scrollTop <= 0;
            if (atTop && y > lastY) {
              event.preventDefault();
            }
            lastY = y;
          }
          send({ type: "POINTER_MOVE", point, target });
        }
        function onTouchEnd(event) {
          if (event.touches.length !== 0) return;
          const point = domQuery.getEventPoint(event);
          send({ type: "POINTER_UP", point });
        }
        const cleanups = [
          domQuery.addDomEvent(scope.getDoc(), "pointermove", onPointerMove),
          domQuery.addDomEvent(scope.getDoc(), "pointerup", onPointerUp),
          domQuery.addDomEvent(scope.getDoc(), "touchstart", onTouchStart, { passive: false }),
          domQuery.addDomEvent(scope.getDoc(), "touchmove", onTouchMove, { passive: false }),
          domQuery.addDomEvent(scope.getDoc(), "touchend", onTouchEnd)
        ];
        return () => {
          cleanups.forEach((cleanup) => cleanup());
        };
      },
      trackContentHeight({ context, scope }) {
        const contentEl = getContentEl(scope);
        if (!contentEl) return;
        const win = scope.getWin();
        const updateHeight = () => {
          const rect = contentEl.getBoundingClientRect();
          context.set("contentHeight", rect.height);
        };
        updateHeight();
        const observer = new win.ResizeObserver(() => {
          updateHeight();
        });
        observer.observe(contentEl);
        return () => {
          observer.disconnect();
        };
      },
      trackExitAnimation({ send, scope }) {
        let cleanup;
        const rafCleanup = domQuery.raf(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = getComputedStyle(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "ANIMATION_END" });
            return;
          }
          const onEnd = (event) => {
            const target = domQuery.getEventTarget(event);
            if (target === contentEl) {
              send({ type: "ANIMATION_END" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
          };
        });
        return () => {
          rafCleanup();
          cleanup?.();
        };
      }
    }
  }
});
var props = types.createProps()([
  "id",
  "ids",
  "dir",
  "modal",
  "initialFocusEl",
  "finalFocusEl",
  "open",
  "defaultOpen",
  "getRootNode",
  "snapPoints",
  "swipeVelocityThreshold",
  "closeThreshold",
  "preventDragOnScroll",
  "closeOnEscape",
  "closeOnInteractOutside",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onRequestDismiss",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus",
  "defaultActiveSnapPoint",
  "activeSnapPoint",
  "onActiveSnapPointChange"
]);
var splitProps = utils.createSplitProps(props);

exports.anatomy = anatomy;
exports.connect = connect;
exports.machine = machine;
exports.props = props;
exports.splitProps = splitProps;
