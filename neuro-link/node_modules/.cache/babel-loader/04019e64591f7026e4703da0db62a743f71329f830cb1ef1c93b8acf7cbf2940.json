{"ast":null,"code":"import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n  /**\r\n   * WAAPI doesn't support interrupting animations.\r\n   *\r\n   * Therefore, starting animations requires a three-step process:\r\n   * 1. Stop existing animations (write styles to DOM)\r\n   * 2. Resolve keyframes (read styles from DOM)\r\n   * 3. Create new animations (write styles to DOM)\r\n   *\r\n   * The hybrid `animate()` function uses AsyncAnimation to resolve\r\n   * keyframes before creating new animations, which removes style\r\n   * thrashing. Here, we have much stricter filesize constraints.\r\n   * Therefore we do this in a synchronous way that ensures that\r\n   * at least within `animate()` calls there is no style thrashing.\r\n   *\r\n   * In the motion-native-animate-mini-interrupt benchmark this\r\n   * was 80% faster than a single loop.\r\n   */\n  const animationDefinitions = [];\n  /**\r\n   * Step 1: Build options and stop existing animations (write)\r\n   */\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    const elementTransition = {\n      ...options\n    };\n    /**\r\n     * Resolve stagger function if provided.\r\n     */\n    if (typeof elementTransition.delay === \"function\") {\n      elementTransition.delay = elementTransition.delay(i, numElements);\n    }\n    for (const valueName in keyframes) {\n      let valueKeyframes = keyframes[valueName];\n      if (!Array.isArray(valueKeyframes)) {\n        valueKeyframes = [valueKeyframes];\n      }\n      const valueOptions = {\n        ...getValueTransition(elementTransition, valueName)\n      };\n      valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n      valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n      /**\r\n       * If there's an existing animation playing on this element then stop it\r\n       * before creating a new one.\r\n       */\n      const map = getAnimationMap(element);\n      const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n      const currentAnimation = map.get(key);\n      currentAnimation && currentAnimation.stop();\n      animationDefinitions.push({\n        map,\n        key,\n        unresolvedKeyframes: valueKeyframes,\n        options: {\n          ...valueOptions,\n          element,\n          name: valueName,\n          allowFlatten: !elementTransition.type && !elementTransition.ease\n        }\n      });\n    }\n  }\n  /**\r\n   * Step 2: Resolve keyframes (read)\r\n   */\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      unresolvedKeyframes,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const {\n      element,\n      name,\n      pseudoElement\n    } = animationOptions;\n    if (!pseudoElement && unresolvedKeyframes[0] === null) {\n      unresolvedKeyframes[0] = getComputedStyle(element, name);\n    }\n    fillWildcards(unresolvedKeyframes);\n    applyPxDefaults(unresolvedKeyframes, name);\n    /**\r\n     * If we only have one keyframe, explicitly read the initial keyframe\r\n     * from the computed style. This is to ensure consistency with WAAPI behaviour\r\n     * for restarting animations, for instance .play() after finish, when it\r\n     * has one vs two keyframes.\r\n     */\n    if (!pseudoElement && unresolvedKeyframes.length < 2) {\n      unresolvedKeyframes.unshift(getComputedStyle(element, name));\n    }\n    animationOptions.keyframes = unresolvedKeyframes;\n  }\n  /**\r\n   * Step 3: Create new animations (write)\r\n   */\n  const animations = [];\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      map,\n      key,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const animation = new NativeAnimation(animationOptions);\n    map.set(key, animation);\n    animation.finished.finally(() => map.delete(key));\n    animations.push(animation);\n  }\n  return animations;\n}\nexport { animateElements };","map":{"version":3,"names":["resolveElements","getValueTransition","getAnimationMap","animationMapKey","getComputedStyle","fillWildcards","applyPxDefaults","NativeAnimation","invariant","secondsToMilliseconds","animateElements","elementOrSelector","keyframes","options","scope","elements","numElements","length","Boolean","animationDefinitions","i","element","elementTransition","delay","valueName","valueKeyframes","Array","isArray","valueOptions","duration","map","key","pseudoElement","currentAnimation","get","stop","push","unresolvedKeyframes","name","allowFlatten","type","ease","animationOptions","unshift","animations","animation","set","finished","finally","delete"],"sources":["C:/Users/Zabdiel Julian/Downloads/Cognia-dev/neuro-link/node_modules/framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs"],"sourcesContent":["import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\r\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\r\n\r\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\r\n    const elements = resolveElements(elementOrSelector, scope);\r\n    const numElements = elements.length;\r\n    invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\r\n    /**\r\n     * WAAPI doesn't support interrupting animations.\r\n     *\r\n     * Therefore, starting animations requires a three-step process:\r\n     * 1. Stop existing animations (write styles to DOM)\r\n     * 2. Resolve keyframes (read styles from DOM)\r\n     * 3. Create new animations (write styles to DOM)\r\n     *\r\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\r\n     * keyframes before creating new animations, which removes style\r\n     * thrashing. Here, we have much stricter filesize constraints.\r\n     * Therefore we do this in a synchronous way that ensures that\r\n     * at least within `animate()` calls there is no style thrashing.\r\n     *\r\n     * In the motion-native-animate-mini-interrupt benchmark this\r\n     * was 80% faster than a single loop.\r\n     */\r\n    const animationDefinitions = [];\r\n    /**\r\n     * Step 1: Build options and stop existing animations (write)\r\n     */\r\n    for (let i = 0; i < numElements; i++) {\r\n        const element = elements[i];\r\n        const elementTransition = { ...options };\r\n        /**\r\n         * Resolve stagger function if provided.\r\n         */\r\n        if (typeof elementTransition.delay === \"function\") {\r\n            elementTransition.delay = elementTransition.delay(i, numElements);\r\n        }\r\n        for (const valueName in keyframes) {\r\n            let valueKeyframes = keyframes[valueName];\r\n            if (!Array.isArray(valueKeyframes)) {\r\n                valueKeyframes = [valueKeyframes];\r\n            }\r\n            const valueOptions = {\r\n                ...getValueTransition(elementTransition, valueName),\r\n            };\r\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\r\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\r\n            /**\r\n             * If there's an existing animation playing on this element then stop it\r\n             * before creating a new one.\r\n             */\r\n            const map = getAnimationMap(element);\r\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\r\n            const currentAnimation = map.get(key);\r\n            currentAnimation && currentAnimation.stop();\r\n            animationDefinitions.push({\r\n                map,\r\n                key,\r\n                unresolvedKeyframes: valueKeyframes,\r\n                options: {\r\n                    ...valueOptions,\r\n                    element,\r\n                    name: valueName,\r\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\r\n                },\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Step 2: Resolve keyframes (read)\r\n     */\r\n    for (let i = 0; i < animationDefinitions.length; i++) {\r\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\r\n        const { element, name, pseudoElement } = animationOptions;\r\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\r\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\r\n        }\r\n        fillWildcards(unresolvedKeyframes);\r\n        applyPxDefaults(unresolvedKeyframes, name);\r\n        /**\r\n         * If we only have one keyframe, explicitly read the initial keyframe\r\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\r\n         * for restarting animations, for instance .play() after finish, when it\r\n         * has one vs two keyframes.\r\n         */\r\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\r\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\r\n        }\r\n        animationOptions.keyframes = unresolvedKeyframes;\r\n    }\r\n    /**\r\n     * Step 3: Create new animations (write)\r\n     */\r\n    const animations = [];\r\n    for (let i = 0; i < animationDefinitions.length; i++) {\r\n        const { map, key, options: animationOptions } = animationDefinitions[i];\r\n        const animation = new NativeAnimation(animationOptions);\r\n        map.set(key, animation);\r\n        animation.finished.finally(() => map.delete(key));\r\n        animations.push(animation);\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateElements };\r\n"],"mappings":"AAAA,SAASA,eAAe,EAAEC,kBAAkB,EAAEC,eAAe,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,aAAa,EAAEC,eAAe,EAAEC,eAAe,QAAQ,YAAY;AACrK,SAASC,SAAS,EAAEC,qBAAqB,QAAQ,cAAc;AAE/D,SAASC,eAAeA,CAACC,iBAAiB,EAAEC,SAAS,EAAEC,OAAO,EAAEC,KAAK,EAAE;EACnE,MAAMC,QAAQ,GAAGf,eAAe,CAACW,iBAAiB,EAAEG,KAAK,CAAC;EAC1D,MAAME,WAAW,GAAGD,QAAQ,CAACE,MAAM;EACnCT,SAAS,CAACU,OAAO,CAACF,WAAW,CAAC,EAAE,6BAA6B,EAAE,mBAAmB,CAAC;EACnF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMG,oBAAoB,GAAG,EAAE;EAC/B;AACJ;AACA;EACI,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;IAClC,MAAMC,OAAO,GAAGN,QAAQ,CAACK,CAAC,CAAC;IAC3B,MAAME,iBAAiB,GAAG;MAAE,GAAGT;IAAQ,CAAC;IACxC;AACR;AACA;IACQ,IAAI,OAAOS,iBAAiB,CAACC,KAAK,KAAK,UAAU,EAAE;MAC/CD,iBAAiB,CAACC,KAAK,GAAGD,iBAAiB,CAACC,KAAK,CAACH,CAAC,EAAEJ,WAAW,CAAC;IACrE;IACA,KAAK,MAAMQ,SAAS,IAAIZ,SAAS,EAAE;MAC/B,IAAIa,cAAc,GAAGb,SAAS,CAACY,SAAS,CAAC;MACzC,IAAI,CAACE,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC,EAAE;QAChCA,cAAc,GAAG,CAACA,cAAc,CAAC;MACrC;MACA,MAAMG,YAAY,GAAG;QACjB,GAAG3B,kBAAkB,CAACqB,iBAAiB,EAAEE,SAAS;MACtD,CAAC;MACDI,YAAY,CAACC,QAAQ,KAAKD,YAAY,CAACC,QAAQ,GAAGpB,qBAAqB,CAACmB,YAAY,CAACC,QAAQ,CAAC,CAAC;MAC/FD,YAAY,CAACL,KAAK,KAAKK,YAAY,CAACL,KAAK,GAAGd,qBAAqB,CAACmB,YAAY,CAACL,KAAK,CAAC,CAAC;MACtF;AACZ;AACA;AACA;MACY,MAAMO,GAAG,GAAG5B,eAAe,CAACmB,OAAO,CAAC;MACpC,MAAMU,GAAG,GAAG5B,eAAe,CAACqB,SAAS,EAAEI,YAAY,CAACI,aAAa,IAAI,EAAE,CAAC;MACxE,MAAMC,gBAAgB,GAAGH,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;MACrCE,gBAAgB,IAAIA,gBAAgB,CAACE,IAAI,CAAC,CAAC;MAC3ChB,oBAAoB,CAACiB,IAAI,CAAC;QACtBN,GAAG;QACHC,GAAG;QACHM,mBAAmB,EAAEZ,cAAc;QACnCZ,OAAO,EAAE;UACL,GAAGe,YAAY;UACfP,OAAO;UACPiB,IAAI,EAAEd,SAAS;UACfe,YAAY,EAAE,CAACjB,iBAAiB,CAACkB,IAAI,IAAI,CAAClB,iBAAiB,CAACmB;QAChE;MACJ,CAAC,CAAC;IACN;EACJ;EACA;AACJ;AACA;EACI,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,oBAAoB,CAACF,MAAM,EAAEG,CAAC,EAAE,EAAE;IAClD,MAAM;MAAEiB,mBAAmB;MAAExB,OAAO,EAAE6B;IAAiB,CAAC,GAAGvB,oBAAoB,CAACC,CAAC,CAAC;IAClF,MAAM;MAAEC,OAAO;MAAEiB,IAAI;MAAEN;IAAc,CAAC,GAAGU,gBAAgB;IACzD,IAAI,CAACV,aAAa,IAAIK,mBAAmB,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACnDA,mBAAmB,CAAC,CAAC,CAAC,GAAGjC,gBAAgB,CAACiB,OAAO,EAAEiB,IAAI,CAAC;IAC5D;IACAjC,aAAa,CAACgC,mBAAmB,CAAC;IAClC/B,eAAe,CAAC+B,mBAAmB,EAAEC,IAAI,CAAC;IAC1C;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACN,aAAa,IAAIK,mBAAmB,CAACpB,MAAM,GAAG,CAAC,EAAE;MAClDoB,mBAAmB,CAACM,OAAO,CAACvC,gBAAgB,CAACiB,OAAO,EAAEiB,IAAI,CAAC,CAAC;IAChE;IACAI,gBAAgB,CAAC9B,SAAS,GAAGyB,mBAAmB;EACpD;EACA;AACJ;AACA;EACI,MAAMO,UAAU,GAAG,EAAE;EACrB,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,oBAAoB,CAACF,MAAM,EAAEG,CAAC,EAAE,EAAE;IAClD,MAAM;MAAEU,GAAG;MAAEC,GAAG;MAAElB,OAAO,EAAE6B;IAAiB,CAAC,GAAGvB,oBAAoB,CAACC,CAAC,CAAC;IACvE,MAAMyB,SAAS,GAAG,IAAItC,eAAe,CAACmC,gBAAgB,CAAC;IACvDZ,GAAG,CAACgB,GAAG,CAACf,GAAG,EAAEc,SAAS,CAAC;IACvBA,SAAS,CAACE,QAAQ,CAACC,OAAO,CAAC,MAAMlB,GAAG,CAACmB,MAAM,CAAClB,GAAG,CAAC,CAAC;IACjDa,UAAU,CAACR,IAAI,CAACS,SAAS,CAAC;EAC9B;EACA,OAAOD,UAAU;AACrB;AAEA,SAASlC,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}