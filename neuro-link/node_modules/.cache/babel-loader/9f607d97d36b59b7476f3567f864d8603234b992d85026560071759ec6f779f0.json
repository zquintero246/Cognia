{"ast":null,"code":"import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\r\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\r\n */\nclass NativeAnimation extends WithPromise {\n  constructor(options) {\n    super();\n    this.finishedTime = null;\n    this.isStopped = false;\n    if (!options) return;\n    const {\n      element,\n      name,\n      keyframes,\n      pseudoElement,\n      allowFlatten = false,\n      finalKeyframe,\n      onComplete\n    } = options;\n    this.isPseudoElement = Boolean(pseudoElement);\n    this.allowFlatten = allowFlatten;\n    this.options = options;\n    invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n    const transition = applyGeneratorOptions(options);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n    this.animation.onfinish = () => {\n      this.finishedTime = this.time;\n      if (!pseudoElement) {\n        const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        if (this.updateMotionValue) {\n          this.updateMotionValue(keyframe);\n        } else {\n          /**\r\n           * If we can, we want to commit the final style as set by the user,\r\n           * rather than the computed keyframe value supplied by the animation.\r\n           */\n          setStyle(element, name, keyframe);\n        }\n        this.animation.cancel();\n      }\n      onComplete?.();\n      this.notifyFinished();\n    };\n  }\n  play() {\n    if (this.isStopped) return;\n    this.animation.play();\n    if (this.state === \"finished\") {\n      this.updateFinished();\n    }\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.finish?.();\n  }\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n  }\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    const {\n      state\n    } = this;\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n    if (this.updateMotionValue) {\n      this.updateMotionValue();\n    } else {\n      this.commitStyles();\n    }\n    if (!this.isPseudoElement) this.cancel();\n  }\n  /**\r\n   * WAAPI doesn't natively have any interruption capabilities.\r\n   *\r\n   * In this method, we commit styles back to the DOM before cancelling\r\n   * the animation.\r\n   *\r\n   * This is designed to be overridden by NativeAnimationExtended, which\r\n   * will create a renderless JS animation and sample it twice to calculate\r\n   * its current value, \"previous\" value, and therefore allow\r\n   * Motion to also correctly calculate velocity for any subsequent animation\r\n   * while deferring the commit until the next animation frame.\r\n   */\n  commitStyles() {\n    if (!this.isPseudoElement) {\n      this.animation.commitStyles?.();\n    }\n  }\n  get duration() {\n    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n    return millisecondsToSeconds(Number(duration));\n  }\n  get iterationDuration() {\n    const {\n      delay = 0\n    } = this.options || {};\n    return this.duration + millisecondsToSeconds(delay);\n  }\n  get time() {\n    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n  set time(newTime) {\n    this.finishedTime = null;\n    this.animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  /**\r\n   * The playback speed of the animation.\r\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\r\n   */\n  get speed() {\n    return this.animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    // Allow backwards playback after finishing\n    if (newSpeed < 0) this.finishedTime = null;\n    this.animation.playbackRate = newSpeed;\n  }\n  get state() {\n    return this.finishedTime !== null ? \"finished\" : this.animation.playState;\n  }\n  get startTime() {\n    return Number(this.animation.startTime);\n  }\n  set startTime(newStartTime) {\n    this.animation.startTime = newStartTime;\n  }\n  /**\r\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\r\n   */\n  attachTimeline({\n    timeline,\n    observe\n  }) {\n    if (this.allowFlatten) {\n      this.animation.effect?.updateTiming({\n        easing: \"linear\"\n      });\n    }\n    this.animation.onfinish = null;\n    if (timeline && supportsScrollTimeline()) {\n      this.animation.timeline = timeline;\n      return noop;\n    } else {\n      return observe(this);\n    }\n  }\n}\nexport { NativeAnimation };","map":{"version":3,"names":["invariant","millisecondsToSeconds","secondsToMilliseconds","noop","setStyle","supportsScrollTimeline","getFinalKeyframe","WithPromise","startWaapiAnimation","applyGeneratorOptions","NativeAnimation","constructor","options","finishedTime","isStopped","element","name","keyframes","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","type","transition","animation","autoplay","pause","onfinish","time","keyframe","speed","updateMotionValue","cancel","notifyFinished","play","state","updateFinished","complete","finish","e","stop","commitStyles","duration","effect","getComputedTiming","Number","iterationDuration","delay","currentTime","newTime","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","timeline","observe","updateTiming","easing"],"sources":["C:/Users/Zabdiel Julian/Downloads/Cognia-dev/neuro-link/node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs"],"sourcesContent":["import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\r\nimport { setStyle } from '../render/dom/style-set.mjs';\r\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\r\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\r\nimport { WithPromise } from './utils/WithPromise.mjs';\r\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\r\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\r\n\r\n/**\r\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\r\n */\r\nclass NativeAnimation extends WithPromise {\r\n    constructor(options) {\r\n        super();\r\n        this.finishedTime = null;\r\n        this.isStopped = false;\r\n        if (!options)\r\n            return;\r\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\r\n        this.isPseudoElement = Boolean(pseudoElement);\r\n        this.allowFlatten = allowFlatten;\r\n        this.options = options;\r\n        invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\r\n        const transition = applyGeneratorOptions(options);\r\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\r\n        if (transition.autoplay === false) {\r\n            this.animation.pause();\r\n        }\r\n        this.animation.onfinish = () => {\r\n            this.finishedTime = this.time;\r\n            if (!pseudoElement) {\r\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\r\n                if (this.updateMotionValue) {\r\n                    this.updateMotionValue(keyframe);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If we can, we want to commit the final style as set by the user,\r\n                     * rather than the computed keyframe value supplied by the animation.\r\n                     */\r\n                    setStyle(element, name, keyframe);\r\n                }\r\n                this.animation.cancel();\r\n            }\r\n            onComplete?.();\r\n            this.notifyFinished();\r\n        };\r\n    }\r\n    play() {\r\n        if (this.isStopped)\r\n            return;\r\n        this.animation.play();\r\n        if (this.state === \"finished\") {\r\n            this.updateFinished();\r\n        }\r\n    }\r\n    pause() {\r\n        this.animation.pause();\r\n    }\r\n    complete() {\r\n        this.animation.finish?.();\r\n    }\r\n    cancel() {\r\n        try {\r\n            this.animation.cancel();\r\n        }\r\n        catch (e) { }\r\n    }\r\n    stop() {\r\n        if (this.isStopped)\r\n            return;\r\n        this.isStopped = true;\r\n        const { state } = this;\r\n        if (state === \"idle\" || state === \"finished\") {\r\n            return;\r\n        }\r\n        if (this.updateMotionValue) {\r\n            this.updateMotionValue();\r\n        }\r\n        else {\r\n            this.commitStyles();\r\n        }\r\n        if (!this.isPseudoElement)\r\n            this.cancel();\r\n    }\r\n    /**\r\n     * WAAPI doesn't natively have any interruption capabilities.\r\n     *\r\n     * In this method, we commit styles back to the DOM before cancelling\r\n     * the animation.\r\n     *\r\n     * This is designed to be overridden by NativeAnimationExtended, which\r\n     * will create a renderless JS animation and sample it twice to calculate\r\n     * its current value, \"previous\" value, and therefore allow\r\n     * Motion to also correctly calculate velocity for any subsequent animation\r\n     * while deferring the commit until the next animation frame.\r\n     */\r\n    commitStyles() {\r\n        if (!this.isPseudoElement) {\r\n            this.animation.commitStyles?.();\r\n        }\r\n    }\r\n    get duration() {\r\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\r\n        return millisecondsToSeconds(Number(duration));\r\n    }\r\n    get iterationDuration() {\r\n        const { delay = 0 } = this.options || {};\r\n        return this.duration + millisecondsToSeconds(delay);\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\r\n    }\r\n    set time(newTime) {\r\n        this.finishedTime = null;\r\n        this.animation.currentTime = secondsToMilliseconds(newTime);\r\n    }\r\n    /**\r\n     * The playback speed of the animation.\r\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\r\n     */\r\n    get speed() {\r\n        return this.animation.playbackRate;\r\n    }\r\n    set speed(newSpeed) {\r\n        // Allow backwards playback after finishing\r\n        if (newSpeed < 0)\r\n            this.finishedTime = null;\r\n        this.animation.playbackRate = newSpeed;\r\n    }\r\n    get state() {\r\n        return this.finishedTime !== null\r\n            ? \"finished\"\r\n            : this.animation.playState;\r\n    }\r\n    get startTime() {\r\n        return Number(this.animation.startTime);\r\n    }\r\n    set startTime(newStartTime) {\r\n        this.animation.startTime = newStartTime;\r\n    }\r\n    /**\r\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\r\n     */\r\n    attachTimeline({ timeline, observe }) {\r\n        if (this.allowFlatten) {\r\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\r\n        }\r\n        this.animation.onfinish = null;\r\n        if (timeline && supportsScrollTimeline()) {\r\n            this.animation.timeline = timeline;\r\n            return noop;\r\n        }\r\n        else {\r\n            return observe(this);\r\n        }\r\n    }\r\n}\r\n\r\nexport { NativeAnimation };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}