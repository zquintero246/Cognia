{"ast":null,"code":"import { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => onComplete => {\n  const valueTransition = getValueTransition(transition, name) || {};\n  /**\r\n   * Most transition values are currently completely overwritten by value-specific\r\n   * transitions. In the future it'd be nicer to blend these transitions. But for now\r\n   * delay actually does inherit from the root transition if not value-specific.\r\n   */\n  const delay = valueTransition.delay || transition.delay || 0;\n  /**\r\n   * Elapsed isn't a public transition option but can be passed through from\r\n   * optimized appear effects in milliseconds.\r\n   */\n  let {\n    elapsed = 0\n  } = transition;\n  elapsed = elapsed - secondsToMilliseconds(delay);\n  const options = {\n    keyframes: Array.isArray(target) ? target : [null, target],\n    ease: \"easeOut\",\n    velocity: value.getVelocity(),\n    ...valueTransition,\n    delay: -elapsed,\n    onUpdate: v => {\n      value.set(v);\n      valueTransition.onUpdate && valueTransition.onUpdate(v);\n    },\n    onComplete: () => {\n      onComplete();\n      valueTransition.onComplete && valueTransition.onComplete();\n    },\n    name,\n    motionValue: value,\n    element: isHandoff ? undefined : element\n  };\n  /**\r\n   * If there's no transition defined for this value, we can generate\r\n   * unique transition settings for this value.\r\n   */\n  if (!isTransitionDefined(valueTransition)) {\n    Object.assign(options, getDefaultTransition(name, options));\n  }\n  /**\r\n   * Both WAAPI and our internal animation functions use durations\r\n   * as defined by milliseconds, while our external API defines them\r\n   * as seconds.\r\n   */\n  options.duration && (options.duration = secondsToMilliseconds(options.duration));\n  options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n  /**\r\n   * Support deprecated way to set initial value. Prefer keyframe syntax.\r\n   */\n  if (options.from !== undefined) {\n    options.keyframes[0] = options.from;\n  }\n  let shouldSkip = false;\n  if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n    makeAnimationInstant(options);\n    if (options.delay === 0) {\n      shouldSkip = true;\n    }\n  }\n  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {\n    shouldSkip = true;\n    makeAnimationInstant(options);\n    options.delay = 0;\n  }\n  /**\r\n   * If the transition type or easing has been explicitly set by the user\r\n   * then we don't want to allow flattening the animation.\r\n   */\n  options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n  /**\r\n   * If we can or must skip creating the animation, and apply only\r\n   * the final keyframe, do so. We also check once keyframes are resolved but\r\n   * this early check prevents the need to create an animation at all.\r\n   */\n  if (shouldSkip && !isHandoff && value.get() !== undefined) {\n    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n    if (finalKeyframe !== undefined) {\n      frame.update(() => {\n        options.onUpdate(finalKeyframe);\n        options.onComplete();\n      });\n      return;\n    }\n  }\n  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);\n};\nexport { animateMotionValue };","map":{"version":3,"names":["getValueTransition","makeAnimationInstant","frame","JSAnimation","AsyncMotionValueAnimation","secondsToMilliseconds","MotionGlobalConfig","getFinalKeyframe","getDefaultTransition","isTransitionDefined","animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","Object","assign","duration","repeatDelay","from","shouldSkip","type","instantAnimations","skipAnimations","allowFlatten","get","finalKeyframe","update","isSync"],"sources":["C:/Users/Zabdiel Julian/Downloads/Cognia-dev/neuro-link/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\r\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\r\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\r\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\r\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\r\n\r\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\r\n    const valueTransition = getValueTransition(transition, name) || {};\r\n    /**\r\n     * Most transition values are currently completely overwritten by value-specific\r\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\r\n     * delay actually does inherit from the root transition if not value-specific.\r\n     */\r\n    const delay = valueTransition.delay || transition.delay || 0;\r\n    /**\r\n     * Elapsed isn't a public transition option but can be passed through from\r\n     * optimized appear effects in milliseconds.\r\n     */\r\n    let { elapsed = 0 } = transition;\r\n    elapsed = elapsed - secondsToMilliseconds(delay);\r\n    const options = {\r\n        keyframes: Array.isArray(target) ? target : [null, target],\r\n        ease: \"easeOut\",\r\n        velocity: value.getVelocity(),\r\n        ...valueTransition,\r\n        delay: -elapsed,\r\n        onUpdate: (v) => {\r\n            value.set(v);\r\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\r\n        },\r\n        onComplete: () => {\r\n            onComplete();\r\n            valueTransition.onComplete && valueTransition.onComplete();\r\n        },\r\n        name,\r\n        motionValue: value,\r\n        element: isHandoff ? undefined : element,\r\n    };\r\n    /**\r\n     * If there's no transition defined for this value, we can generate\r\n     * unique transition settings for this value.\r\n     */\r\n    if (!isTransitionDefined(valueTransition)) {\r\n        Object.assign(options, getDefaultTransition(name, options));\r\n    }\r\n    /**\r\n     * Both WAAPI and our internal animation functions use durations\r\n     * as defined by milliseconds, while our external API defines them\r\n     * as seconds.\r\n     */\r\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\r\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\r\n    /**\r\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\r\n     */\r\n    if (options.from !== undefined) {\r\n        options.keyframes[0] = options.from;\r\n    }\r\n    let shouldSkip = false;\r\n    if (options.type === false ||\r\n        (options.duration === 0 && !options.repeatDelay)) {\r\n        makeAnimationInstant(options);\r\n        if (options.delay === 0) {\r\n            shouldSkip = true;\r\n        }\r\n    }\r\n    if (MotionGlobalConfig.instantAnimations ||\r\n        MotionGlobalConfig.skipAnimations) {\r\n        shouldSkip = true;\r\n        makeAnimationInstant(options);\r\n        options.delay = 0;\r\n    }\r\n    /**\r\n     * If the transition type or easing has been explicitly set by the user\r\n     * then we don't want to allow flattening the animation.\r\n     */\r\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\r\n    /**\r\n     * If we can or must skip creating the animation, and apply only\r\n     * the final keyframe, do so. We also check once keyframes are resolved but\r\n     * this early check prevents the need to create an animation at all.\r\n     */\r\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\r\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\r\n        if (finalKeyframe !== undefined) {\r\n            frame.update(() => {\r\n                options.onUpdate(finalKeyframe);\r\n                options.onComplete();\r\n            });\r\n            return;\r\n        }\r\n    }\r\n    return valueTransition.isSync\r\n        ? new JSAnimation(options)\r\n        : new AsyncMotionValueAnimation(options);\r\n};\r\n\r\nexport { animateMotionValue };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}