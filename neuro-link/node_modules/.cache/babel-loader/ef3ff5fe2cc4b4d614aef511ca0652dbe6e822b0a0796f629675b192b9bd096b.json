{"ast":null,"code":"import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nfunction test(v) {\n  return isNaN(v) && typeof v === \"string\" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const values = [];\n  const indexes = {\n    color: [],\n    number: [],\n    var: []\n  };\n  const types = [];\n  let i = 0;\n  const tokenised = originalValue.replace(complexRegex, parsedValue => {\n    if (color.test(parsedValue)) {\n      indexes.color.push(i);\n      types.push(COLOR_TOKEN);\n      values.push(color.parse(parsedValue));\n    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n      indexes.var.push(i);\n      types.push(VAR_TOKEN);\n      values.push(parsedValue);\n    } else {\n      indexes.number.push(i);\n      types.push(NUMBER_TOKEN);\n      values.push(parseFloat(parsedValue));\n    }\n    ++i;\n    return SPLIT_TOKEN;\n  });\n  const split = tokenised.split(SPLIT_TOKEN);\n  return {\n    values,\n    split,\n    indexes,\n    types\n  };\n}\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n  const {\n    split,\n    types\n  } = analyseComplexValue(source);\n  const numSections = split.length;\n  return v => {\n    let output = \"\";\n    for (let i = 0; i < numSections; i++) {\n      output += split[i];\n      if (v[i] !== undefined) {\n        const type = types[i];\n        if (type === NUMBER_TOKEN) {\n          output += sanitize(v[i]);\n        } else if (type === COLOR_TOKEN) {\n          output += color.transform(v[i]);\n        } else {\n          output += v[i];\n        }\n      }\n    }\n    return output;\n  };\n}\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\nfunction getAnimatableNone(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"names":["color","colorRegex","floatRegex","sanitize","test","v","isNaN","match","length","NUMBER_TOKEN","COLOR_TOKEN","VAR_TOKEN","VAR_FUNCTION_TOKEN","SPLIT_TOKEN","complexRegex","analyseComplexValue","value","originalValue","toString","values","indexes","number","var","types","i","tokenised","replace","parsedValue","push","parse","startsWith","parseFloat","split","parseComplexValue","createTransformer","source","numSections","output","undefined","type","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","map","complex"],"sources":["C:/Users/Zabdiel Julian/Downloads/Cognia-dev/neuro-link/node_modules/motion-dom/dist/es/value/types/complex/index.mjs"],"sourcesContent":["import { color } from '../color/index.mjs';\r\nimport { colorRegex } from '../utils/color-regex.mjs';\r\nimport { floatRegex } from '../utils/float-regex.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\n\r\nfunction test(v) {\r\n    return (isNaN(v) &&\r\n        typeof v === \"string\" &&\r\n        (v.match(floatRegex)?.length || 0) +\r\n            (v.match(colorRegex)?.length || 0) >\r\n            0);\r\n}\r\nconst NUMBER_TOKEN = \"number\";\r\nconst COLOR_TOKEN = \"color\";\r\nconst VAR_TOKEN = \"var\";\r\nconst VAR_FUNCTION_TOKEN = \"var(\";\r\nconst SPLIT_TOKEN = \"${}\";\r\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\r\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\r\nfunction analyseComplexValue(value) {\r\n    const originalValue = value.toString();\r\n    const values = [];\r\n    const indexes = {\r\n        color: [],\r\n        number: [],\r\n        var: [],\r\n    };\r\n    const types = [];\r\n    let i = 0;\r\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\r\n        if (color.test(parsedValue)) {\r\n            indexes.color.push(i);\r\n            types.push(COLOR_TOKEN);\r\n            values.push(color.parse(parsedValue));\r\n        }\r\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\r\n            indexes.var.push(i);\r\n            types.push(VAR_TOKEN);\r\n            values.push(parsedValue);\r\n        }\r\n        else {\r\n            indexes.number.push(i);\r\n            types.push(NUMBER_TOKEN);\r\n            values.push(parseFloat(parsedValue));\r\n        }\r\n        ++i;\r\n        return SPLIT_TOKEN;\r\n    });\r\n    const split = tokenised.split(SPLIT_TOKEN);\r\n    return { values, split, indexes, types };\r\n}\r\nfunction parseComplexValue(v) {\r\n    return analyseComplexValue(v).values;\r\n}\r\nfunction createTransformer(source) {\r\n    const { split, types } = analyseComplexValue(source);\r\n    const numSections = split.length;\r\n    return (v) => {\r\n        let output = \"\";\r\n        for (let i = 0; i < numSections; i++) {\r\n            output += split[i];\r\n            if (v[i] !== undefined) {\r\n                const type = types[i];\r\n                if (type === NUMBER_TOKEN) {\r\n                    output += sanitize(v[i]);\r\n                }\r\n                else if (type === COLOR_TOKEN) {\r\n                    output += color.transform(v[i]);\r\n                }\r\n                else {\r\n                    output += v[i];\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n}\r\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\r\nfunction getAnimatableNone(v) {\r\n    const parsed = parseComplexValue(v);\r\n    const transformer = createTransformer(v);\r\n    return transformer(parsed.map(convertNumbersToZero));\r\n}\r\nconst complex = {\r\n    test,\r\n    parse: parseComplexValue,\r\n    createTransformer,\r\n    getAnimatableNone,\r\n};\r\n\r\nexport { analyseComplexValue, complex };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}